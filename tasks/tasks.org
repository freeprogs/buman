#+STARTUP: content logdone hideblocks
#+TODO: TASK(t!) | DONE(d) CANCEL(c)
#+TODO: BUG(b!) | FIXED(f) REJECT(r)
#+PRIORITIES: A F C
#+TAGS: current(c) testing(t)
#+CONSTANTS: last_issue_id=11

* Задачи
  :PROPERTIES:
  :COLUMNS:  %3issue_id(ID) %4issue_type(TYPE) %TODO %40ITEM %SCHEDULED %DEADLINE %1PRIORITY
  :ARCHIVE:  tasks_archive.org::* Архив задач
  :END:

** TASK Придумать систему логирования в программе
   :PROPERTIES:
   :issue_id: 2
   :issue_type: task
   :END:
   [2018-07-08 Вс]

   Должно быть логирование по умолчанию, которое будет регистрировать
   только ошибки (как у wget).

   Лог создаётся и туда пишется информация из всех сессий с
   добавлением в конец.

   Если лог только создался, сверху должен вставиться заголовок, чтобы
   было понятно, от какой программы лог.

   Строка лога должна содержать дату-время до миллисекунд, имя записи,
   тип ошибки, понятное сообщение для пользователя и дополнительные
   данные ошибки для решения проблемы с использованием только этой
   строки лога.

   Должна быть настройка в записи для смены файла лога.

   Должна быть опция отмены логирования для записи, даже если были
   ошибки в процессе работы программы.

** TASK Придумать формат вывода информации на экран
   :PROPERTIES:
   :issue_id: 3
   :issue_type: task
   :END:
   [2018-07-08 Вс]

   Сверху должен писаться заголовок.

   В заголовке должно быть указано, сколько всего объектов будет
   обрабатываться, состояние дефолтных настроек программы (идёт ли
   логирование и куда идёт).

   После заголовка идёт тело процесса выполнения, которое состоит из
   текущих выполняющихся задач.

   Каждая выполняемая задача должна содержать пару (номер объекта,
   всего объектов), имя записи, обрабатываемый источник,
   обрабатываемый приёмник. После выполнения задачи должно писаться
   сообщение о статусе ok или fail.

   Возможно, нужно писать время начала и время конца выполнения
   задачи, чтобы можно было прикинуть время для тяжелых файлов.

   Имя записи и статус завершения задачи нужно писать так, чтобы их
   удобно было искать через grep.

   Внизу идёт подвал со статистикой по всем задачам.

   В статистике должно быть указано, сколько всего объектов
   обработано, сколько скопировано, сколько пропущено, сколько ошибок.

** TASK Придумать поведение для найденных файлов в приёмнике
   :PROPERTIES:
   :issue_id: 4
   :issue_type: task
   :END:
   [2018-07-08 Вс]

   При копировании файла из источника в приёмнике часто будет
   оказываться такой же файл.

   Если файлы одинаковые по хеш-сумме, нужно файл пропускать.

   Если файлы разные, то по умолчанию файл должен перезаписываться
   файлом из источника.

   Должна быть опция, которая устанавливает поведение. Виды поведений:
   переписать безусловно (по умолчанию), пропустить безусловно,
   ротировать.

   Ротация файлов означает, что файл в приёмнике должен
   переименоваться, как в logrotate в linux происходит, и файл из
   источника должен записаться, как будто файла в приёмнике не
   было. При наличие хеша у старого файла, хеш должен так же
   переименоваться, как и сам файл.

** TASK Реализовать точный анализатор файла настроек
   :PROPERTIES:
   :issue_id: 7
   :issue_type: task
   :END:
   [2018-08-31 Пт]

   Нужно сделать разложение на лексемы, а потом сделать конечный
   распознаватель для потока этих лексем.

   Если делать без потока лексем, то надо будет в качестве лексем
   брать отдельные символы. Брать каждый символ неудобно, так как в
   конфиге есть определённые слова, которые по буквам раскладывать нет
   никакого смысла.

** TASK Написать докстринги для всех классов и методов
   :PROPERTIES:
   :issue_id: 8
   :issue_type: task
   :END:
   [2018-08-31 Пт]

   Проверить через help() читаемость докстрингов, когда они собираются
   в одно целое.

** TASK Сделать проверку некорректно установленных опций в файле настроек
   :PROPERTIES:
   :issue_id: 9
   :issue_type: task
   :END:
   [2018-08-31 Пт]

   Например, в опции шифрования может быть указан пароль без алгоритма
   шифрования. В таком случае может быть использован алгоритм по
   умолчанию.

   Надо рассмотреть такой случай, когда значения по умолчанию нет, а
   какие-то неполные опции установлены. Это считается некорректной
   семантикой, на которую нужно выдавать сообщение пользователю.


* Баги
  :PROPERTIES:
  :COLUMNS:  %3issue_id(ID) %4issue_type(TYPE) %TODO %40ITEM %SCHEDULED %DEADLINE %1PRIORITY
  :ARCHIVE:  tasks_archive.org::* Архив багов
  :END:


* Окружение
  :PROPERTIES:
  :COLUMNS:  %3issue_id(ID) %4issue_type(TYPE) %TODO %40ITEM %SCHEDULED %DEADLINE %1PRIORITY
  :ARCHIVE:  tasks_archive.org::* Архив окружения
  :END:

** TASK Создать man-страницу с описанием настроек
   :PROPERTIES:
   :issue_id: 5
   :issue_type: task
   :END:
   [2018-07-14 Сб]

   Нужно описать все возможные поля конфигурационного файла. Нужно
   описать весь его досутпный синтаксис, исключить недокументированные
   возможности.

   Список:
   - Записей может быть несколько
   - В записи может быть несколько источников
   - В записи может быть несколько приёмников
   - В записи может быть одно поле с несколькими опциями
   - В записи может быть несколько полей с опциями
   - Опция может иметь свои настройки
   - Одинаковые опции могут аккумулироваться

   Варианты опций и внутренние настройки каждой опции должны быть все
   описаны.

   Нужно привести несколько разных примеров конфигурационного файла,
   чтобы было понятно, как его лучше писать.

** TASK Создать инфраструктуру для юнит-тестов
   :PROPERTIES:
   :issue_id: 6
   :issue_type: task
   :END:
   [2018-08-31 Пт]

   Нужно добавить также анализ покрытия кода тестами.

** TASK Описать компоненты UML-диаграммы в файле для разработчиков
   :PROPERTIES:
   :issue_id: 10
   :issue_type: task
   :END:
   [2018-08-31 Пт]

   Многие связи на диаграмме сделаны нестандартно, используются многие
   непонятные типы. Нужно описать связи и типы в отдельном файле,
   чтобы незнакомый человек мог понять всё точно.

** TASK Сделать диаграмму использования фич программы
   :PROPERTIES:
   :issue_id: 11
   :issue_type: task
   :END:
   [2018-08-31 Пт]

   Диаграмма использования нужна для того, чтобы очертить точное
   количество необходимых фич в программе. Эта диаграмма покажет все
   возможности программы без погружения в код программы.
